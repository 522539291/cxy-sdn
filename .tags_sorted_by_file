!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_PROGRAM_VERSION	5.9~svn20110310	//
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
init	main.go	/^func init() {$/;"	f
main	main.go	/^func main() {$/;"	f
main	main.go	/^package main$/;"	p
BridgeConf	server/api.go	/^type BridgeConf struct {$/;"	t
Connection	server/api.go	/^type Connection struct {$/;"	t
Err	server/api.go	/^type Err struct {$/;"	t
Handler	server/api.go	/^type Handler struct {$/;"	t
HttpApiFunc	server/api.go	/^type HttpApiFunc func(d *Daemon, w http.ResponseWriter, r *http.Request) *Err$/;"	t
ServeAPI	server/api.go	/^func ServeAPI(d *Daemon) {$/;"	f
ServeHTTP	server/api.go	/^func (handler Handler) ServeHTTP(w http.ResponseWriter, r *http.Request) {$/;"	f
VERSION	server/api.go	/^const VERSION = "0.1"$/;"	c
createRouter	server/api.go	/^func createRouter(d *Daemon) *mux.Router {$/;"	f
getConf	server/api.go	/^func getConf(d *Daemon, w http.ResponseWriter, r *http.Request) *Err {$/;"	f
getCons	server/api.go	/^func getCons(d *Daemon, w http.ResponseWriter, r *http.Request) *Err {$/;"	f
getNets	server/api.go	/^func getNets(d *Daemon, w http.ResponseWriter, r *http.Request) *Err {$/;"	f
getVersion	server/api.go	/^func getVersion(d *Daemon, w http.ResponseWriter, r *http.Request) *Err {$/;"	f
server	server/api.go	/^package server$/;"	p
setConf	server/api.go	/^func setConf(d *Daemon, w http.ResponseWriter, r *http.Request) *Err {$/;"	f
InitAgent	server/backend.go	/^func InitAgent(bindInterface string, bootstrap bool) error {$/;"	f
JoinCluster	server/backend.go	/^func JoinCluster(addr string) error {$/;"	f
LeaveDataStore	server/backend.go	/^func LeaveDataStore() error {$/;"	f
Listener	server/backend.go	/^type Listener struct{}$/;"	t
NotifyKeyUpdate	server/backend.go	/^func (l Listener) NotifyKeyUpdate(nType netAgent.NotifyUpdateType, key string, data []byte) {$/;"	f
NotifyNodeUpdate	server/backend.go	/^func (l Listener) NotifyNodeUpdate(nType netAgent.NotifyUpdateType, nodeAddr string) {$/;"	f
NotifyStoreUpdate	server/backend.go	/^func (l Listener) NotifyStoreUpdate(nType netAgent.NotifyUpdateType, store string, data map[string][]byte) {$/;"	f
dataDir	server/backend.go	/^const dataDir = "\/tmp\/cxy\/"$/;"	c
listener	server/backend.go	/^var listener Listener$/;"	v
server	server/backend.go	/^package server$/;"	p
Daemon	server/daemon.go	/^type Daemon struct {$/;"	t
NewDaemon	server/daemon.go	/^func NewDaemon() *Daemon {$/;"	f
Run	server/daemon.go	/^func (d *Daemon) Run(ctx *cli.Context) {$/;"	f
server	server/daemon.go	/^package server$/;"	p
CreateDefaultNetwork	server/network.go	/^func CreateDefaultNetwork() (*Network, error) {$/;"	f
CreateNetwork	server/network.go	/^func CreateNetwork(name string, subnet *net.IPNet) (*Network, error) {$/;"	f
GetAvailableGwAddress	server/network.go	/^func GetAvailableGwAddress(bridgeIP string) (gwaddr string, err error) {$/;"	f
GetAvailableSubnet	server/network.go	/^func GetAvailableSubnet() (subnet *net.IPNet, err error) {$/;"	f
GetNetwork	server/network.go	/^func GetNetwork(name string) (*Network, error) {$/;"	f
GetNetworks	server/network.go	/^func GetNetworks() ([]Network, error) {$/;"	f
Network	server/network.go	/^type Network struct {$/;"	t
ReleaseIP	server/network.go	/^func ReleaseIP(addr net.IP, subnet net.IPNet) bool {$/;"	f
RequestIP	server/network.go	/^func RequestIP(subnet net.IPNet) net.IP {$/;"	f
allocateVlan	server/network.go	/^func allocateVlan() (uint, error) {$/;"	f
defaultNetwork	server/network.go	/^const defaultNetwork = "default"$/;"	c
gatewayAddrs	server/network.go	/^var gatewayAddrs = []string{$/;"	v
ipStore	server/network.go	/^const ipStore = "ip"$/;"	c
networkStore	server/network.go	/^const networkStore = "network"$/;"	c
server	server/network.go	/^package server$/;"	p
vlanCount	server/network.go	/^const vlanCount = 4096$/;"	c
vlanStore	server/network.go	/^const vlanStore = "vlan"$/;"	c
TestCleanup	server/network_test.go	/^func TestCleanup(t *testing.T) {$/;"	f
TestGetEmptyNetworks	server/network_test.go	/^func TestGetEmptyNetworks(t *testing.T) {$/;"	f
TestGetNetwork	server/network_test.go	/^func TestGetNetwork(t *testing.T) {$/;"	f
TestGetNetworks	server/network_test.go	/^func TestGetNetworks(t *testing.T) {$/;"	f
TestInitAgent	server/network_test.go	/^func TestInitAgent(t *testing.T) {$/;"	f
TestNetworkCleanup	server/network_test.go	/^func TestNetworkCleanup(t *testing.T) {$/;"	f
TestNetworkCreate	server/network_test.go	/^func TestNetworkCreate(t *testing.T) {$/;"	f
TestNetworkInit	server/network_test.go	/^func TestNetworkInit(t *testing.T) {$/;"	f
TestRequestandReleaseIP	server/network_test.go	/^func TestRequestandReleaseIP(t *testing.T) {$/;"	f
server	server/network_test.go	/^package server$/;"	p
subnetArray	server/network_test.go	/^var subnetArray []*net.IPNet$/;"	v
AddConnection	server/ovs.go	/^func AddConnection(nspid int, networkName string) (ovsConnection OvsConnection, err error) {$/;"	f
AddPeer	server/ovs.go	/^func AddPeer(peerIp string) error {$/;"	f
Bridge	server/ovs.go	/^type Bridge struct {$/;"	t
ConnectionAdd	server/ovs.go	/^const ($/;"	c
ConnectionContext	server/ovs.go	/^type ConnectionContext struct {$/;"	t
ConnectionDelete	server/ovs.go	/^	ConnectionUpdate = iota$/;"	c
ConnectionRPCHandler	server/ovs.go	/^func ConnectionRPCHandler(d *Daemon) {$/;"	f
ConnectionUpdate	server/ovs.go	/^	ConnectionAdd    = iota$/;"	c
ContextCache	server/ovs.go	/^var ContextCache map[string]string$/;"	v
CreateBridge	server/ovs.go	/^func CreateBridge() error {$/;"	f
DeleteConnection	server/ovs.go	/^func DeleteConnection(connection OvsConnection) error {$/;"	f
DeletePeer	server/ovs.go	/^func DeletePeer(peerIp string) error {$/;"	f
Disconnected	server/ovs.go	/^func (n notifier) Disconnected(ovsClient *libovsdb.OvsdbClient) {$/;"	f
Echo	server/ovs.go	/^func (n notifier) Echo([]interface{}) {$/;"	f
GenerateRandomName	server/ovs.go	/^func GenerateRandomName(prefix string, size int) (string, error) {$/;"	f
Locked	server/ovs.go	/^func (n notifier) Locked([]interface{}) {$/;"	f
OvsBridge	server/ovs.go	/^var OvsBridge Bridge = Bridge{Name: defaultBridgeName}$/;"	v
OvsConnection	server/ovs.go	/^type OvsConnection struct {$/;"	t
OvsInit	server/ovs.go	/^func OvsInit() {$/;"	f
Stolen	server/ovs.go	/^func (n notifier) Stolen([]interface{}) {$/;"	f
Update	server/ovs.go	/^func (n notifier) Update(context interface{}, tableUpdates libovsdb.TableUpdates) {$/;"	f
UpdateConnectionContext	server/ovs.go	/^func UpdateConnectionContext(ovsPort string, key string, context string) error {$/;"	f
createBridgeIface	server/ovs.go	/^func createBridgeIface(name string) error {$/;"	f
createOvsInternalPort	server/ovs.go	/^func createOvsInternalPort(prefix string, bridge string, tag uint) (port string, err error) {$/;"	f
defaultBridgeName	server/ovs.go	/^const defaultBridgeName = "ovs-br"$/;"	c
generateMacAddr	server/ovs.go	/^func generateMacAddr(ip net.IP) net.HardwareAddr {$/;"	f
installRule	server/ovs.go	/^func installRule(args ...string) ([]byte, error) {$/;"	f
mtu	server/ovs.go	/^const mtu = 1440$/;"	c
notifier	server/ovs.go	/^type notifier struct {$/;"	t
ovs	server/ovs.go	/^var ovs *libovsdb.OvsdbClient$/;"	v
populateContextCache	server/ovs.go	/^func populateContextCache() {$/;"	f
server	server/ovs.go	/^package server$/;"	p
setupIPTables	server/ovs.go	/^func setupIPTables(bridgeName string, bridgeIP string) error {$/;"	f
AddInternalPort	server/ovs_driver.go	/^func AddInternalPort(ovs *libovsdb.OvsdbClient, bridgeName string, portName string, tag uint) error {$/;"	f
CONTEXT_KEY	server/ovs_driver.go	/^const CONTEXT_KEY = "container_id"$/;"	c
CONTEXT_VALUE	server/ovs_driver.go	/^const CONTEXT_VALUE = "container_data"$/;"	c
CreateOVSBridge	server/ovs_driver.go	/^func CreateOVSBridge(ovs *libovsdb.OvsdbClient, bridgeName string) error {$/;"	f
Disconnected	server/ovs_driver.go	/^func (n Notifier) Disconnected(ovsClient *libovsdb.OvsdbClient) {$/;"	f
Echo	server/ovs_driver.go	/^func (n Notifier) Echo([]interface{}) {$/;"	f
GetTableCache	server/ovs_driver.go	/^func GetTableCache(tableName string) map[string]libovsdb.Row {$/;"	f
Locked	server/ovs_driver.go	/^func (n Notifier) Locked([]interface{}) {$/;"	f
Notifier	server/ovs_driver.go	/^type Notifier struct {$/;"	t
Stolen	server/ovs_driver.go	/^func (n Notifier) Stolen([]interface{}) {$/;"	f
Update	server/ovs_driver.go	/^func (n Notifier) Update(context interface{}, tableUpdates libovsdb.TableUpdates) {$/;"	f
UpdatePortContext	server/ovs_driver.go	/^func UpdatePortContext(ovs *libovsdb.OvsdbClient, portName string, key string, context string) error {$/;"	f
addVxlanPort	server/ovs_driver.go	/^func addVxlanPort(ovs *libovsdb.OvsdbClient, bridgeName string, portName string, peerAddress string) {$/;"	f
cache	server/ovs_driver.go	/^var cache map[string]map[string]libovsdb.Row$/;"	v
deletePort	server/ovs_driver.go	/^func deletePort(ovs *libovsdb.OvsdbClient, bridgeName string, portName string) {$/;"	f
getRootUuid	server/ovs_driver.go	/^func getRootUuid() string {$/;"	f
monitorDockerBridge	server/ovs_driver.go	/^func monitorDockerBridge(ovs *libovsdb.OvsdbClient) {$/;"	f
ovs_connect	server/ovs_driver.go	/^func ovs_connect() (*libovsdb.OvsdbClient, error) {$/;"	f
populateCache	server/ovs_driver.go	/^func populateCache(updates libovsdb.TableUpdates) {$/;"	f
portExists	server/ovs_driver.go	/^func portExists(ovs *libovsdb.OvsdbClient, portName string) (bool, error) {$/;"	f
portUuidForName	server/ovs_driver.go	/^func portUuidForName(portName string) string {$/;"	f
quit	server/ovs_driver.go	/^var quit chan bool$/;"	v
server	server/ovs_driver.go	/^package server$/;"	p
update	server/ovs_driver.go	/^var update chan *libovsdb.TableUpdates$/;"	v
ChangeInterfaceName	util/util.go	/^func ChangeInterfaceName(old, newName string) error {$/;"	f
CheckRouteOverlaps	util/util.go	/^func CheckRouteOverlaps(toCheck *net.IPNet) error {$/;"	f
Clear	util/util.go	/^func Clear(a []byte, k uint) {$/;"	f
ErrNetworkOverlaps	util/util.go	/^	ErrNetworkOverlapsWithNameservers = errors.New("requested network overlaps with nameserver")$/;"	v
ErrNetworkOverlapsWithNameservers	util/util.go	/^	ErrNoDefaultRoute                 = errors.New("no default route")$/;"	v
ErrNoDefaultRoute	util/util.go	/^var ($/;"	v
GetDefaultRouteIface	util/util.go	/^func GetDefaultRouteIface() (int, error) {$/;"	f
GetIfaceAddr	util/util.go	/^func GetIfaceAddr(name string) (*net.IPNet, error) {$/;"	f
GetIfaceForRoute	util/util.go	/^func GetIfaceForRoute(address string) (string, error) {$/;"	f
IPCount	util/util.go	/^func IPCount(subnet net.IPNet) float64 {$/;"	f
InterfaceDown	util/util.go	/^func InterfaceDown(name string) error {$/;"	f
InterfaceUp	util/util.go	/^func InterfaceUp(name string) error {$/;"	f
NetworkOverlaps	util/util.go	/^func NetworkOverlaps(netX *net.IPNet, netY *net.IPNet) bool {$/;"	f
NetworkRange	util/util.go	/^func NetworkRange(network *net.IPNet) (net.IP, net.IP) {$/;"	f
NetworkSize	util/util.go	/^func NetworkSize(mask net.IPMask) int32 {$/;"	f
SetDefaultGateway	util/util.go	/^func SetDefaultGateway(ip, ifaceName string) error {$/;"	f
SetInterfaceInNamespaceFd	util/util.go	/^func SetInterfaceInNamespaceFd(name string, fd uintptr) error {$/;"	f
SetInterfaceInNamespacePid	util/util.go	/^func SetInterfaceInNamespacePid(name string, nsPid int) error {$/;"	f
SetInterfaceIp	util/util.go	/^func SetInterfaceIp(name string, rawIp string) error {$/;"	f
SetInterfaceMac	util/util.go	/^func SetInterfaceMac(name string, macaddr string) error {$/;"	f
SetMtu	util/util.go	/^func SetMtu(name string, mtu int) error {$/;"	f
TestAndSet	util/util.go	/^func TestAndSet(a []byte) uint {$/;"	f
set	util/util.go	/^func set(a []byte, k uint) {$/;"	f
test	util/util.go	/^func test(a []byte, k uint) bool {$/;"	f
util	util/util.go	/^package util$/;"	p
TestBitsOperation	util/util_test.go	/^func TestBitsOperation(t *testing.T) {$/;"	f
TestChangeInterfaceName	util/util_test.go	/^func TestChangeInterfaceName(t *testing.T) {$/;"	f
TestCheckRouteOverlaps	util/util_test.go	/^func TestCheckRouteOverlaps(t *testing.T) {$/;"	f
TestGetDefaultRouteIface	util/util_test.go	/^func TestGetDefaultRouteIface(t *testing.T) {$/;"	f
TestGetIfaceForRoute	util/util_test.go	/^func TestGetIfaceForRoute(t *testing.T) {$/;"	f
TestInterfaceUpDown	util/util_test.go	/^func TestInterfaceUpDown(t *testing.T) {$/;"	f
TestNetworkOverlaps	util/util_test.go	/^func TestNetworkOverlaps(t *testing.T) {$/;"	f
TestNetworkRange	util/util_test.go	/^func TestNetworkRange(t *testing.T) {$/;"	f
TestNetworkSize	util/util_test.go	/^func TestNetworkSize(t *testing.T) {$/;"	f
TestSetDefaultGateway	util/util_test.go	/^func TestSetDefaultGateway(t *testing.T) {$/;"	f
TestSetGetInterfaceIp	util/util_test.go	/^func TestSetGetInterfaceIp(t *testing.T) {$/;"	f
TestSetInterfaceInNamespaceFd	util/util_test.go	/^func TestSetInterfaceInNamespaceFd(t *testing.T) {$/;"	f
TestSetInterfaceInNamespacePid	util/util_test.go	/^func TestSetInterfaceInNamespacePid(t *testing.T) {$/;"	f
TestSetInterfaceMac	util/util_test.go	/^func TestSetInterfaceMac(t *testing.T) {$/;"	f
TestSetMtu	util/util_test.go	/^func TestSetMtu(t *testing.T) {$/;"	f
setUp	util/util_test.go	/^func setUp(t *testing.T) tearDown {$/;"	f
tearDown	util/util_test.go	/^type tearDown func()$/;"	t
testIface	util/util_test.go	/^const testIface = "foo0"$/;"	c
util	util/util_test.go	/^package util$/;"	p
